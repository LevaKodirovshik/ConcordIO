using Neuroglia.AsyncApi;
using Neuroglia.AsyncApi.v3;
using NJsonSchema;
using NJsonSchema.Generation;
using System.Dynamic;
using System.Reflection;
using System.Text.Json;

namespace ConcordIO.AsyncApi.Server;

/// <summary>
/// Generates AsyncAPI 3.x documents from discovered .NET types.
/// </summary>
public class AsyncApiDocumentGenerator
{
    private const string DotNetNamespaceExtension = "x-dotnet-namespace";
    private const string DotNetTypeExtension = "x-dotnet-type";
    private const string GeneratorName = "ConcordIO.AsyncApi.Server";

    private readonly SystemTextJsonSchemaGeneratorSettings _schemaSettings;

    public AsyncApiDocumentGenerator()
    {
        _schemaSettings = new SystemTextJsonSchemaGeneratorSettings
        {
            SchemaType = SchemaType.JsonSchema,
            FlattenInheritanceHierarchy = true
        };
    }

    /// <summary>
    /// Generates an AsyncAPI document from discovered types.
    /// </summary>
    /// <param name="title">The document title (typically the assembly/package name).</param>
    /// <param name="version">The document version.</param>
    /// <param name="types">The discovered types to include.</param>
    /// <returns>An AsyncAPI 3.x document.</returns>
    public V3AsyncApiDocument Generate(string title, string version, IEnumerable<DiscoveredType> types)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(title);
        ArgumentException.ThrowIfNullOrWhiteSpace(version);
        ArgumentNullException.ThrowIfNull(types);

        var typeList = types.ToList();

        var document = new V3AsyncApiDocument
        {
            AsyncApi = AsyncApiSpecVersion.V3,
            Info = new V3ApiInfo
            {
                Title = title,
                Version = version,
                Description = $"Generated by {GeneratorName}"
            },
            Channels = [],
            Operations = [],
            Components = new V3ComponentDefinitionCollection
            {
                Messages = [],
                Schemas = []
            }
        };

        // Track all schemas we need to generate (including referenced types)
        var schemasToGenerate = new Dictionary<string, (Type Type, string Namespace)>();

        // First pass: collect all message types and their dependencies
        foreach (var discoveredType in typeList)
        {
            CollectTypeAndDependencies(discoveredType.Type, schemasToGenerate);
        }

        // Generate all schemas
        foreach (var (schemaName, (type, ns)) in schemasToGenerate)
        {
            var schema = GenerateSchema(type, ns);
            document.Components.Schemas![schemaName] = schema;
        }

        // Generate channels, messages, and operations for message types
        foreach (var discoveredType in typeList)
        {
            var type = discoveredType.Type;
            var kind = discoveredType.Kind;
            var typeName = type.Name;
            var fullTypeName = type.FullName ?? typeName;
            var ns = type.Namespace ?? string.Empty;

            // Create message definition
            var message = new V3MessageDefinition
            {
                Name = typeName,
                Title = typeName,
                ContentType = "application/json",
                Payload = new V3SchemaDefinition
                {
                    Reference = $"#/components/schemas/{typeName}"
                }
            };
                    document.Components.Messages![typeName] = message;

                    // Create channel (MassTransit URN format)
                    var channelAddress = $"urn:message:{ns}:{typeName}";
                    var channel = new V3ChannelDefinition
                    {
                        Address = channelAddress,
                        Messages = new()
                        {
                            [typeName] = new V3MessageDefinition
                            {
                                Reference = $"#/components/messages/{typeName}"
                            }
                        }
                    };
                    document.Channels[fullTypeName] = channel;

                    // Create operation based on message kind
                    var operationAction = kind == MessageKind.Event
                        ? V3OperationAction.Receive  // Events are received by subscribers
                        : V3OperationAction.Send;    // Commands are sent to handlers

                    var operation = new V3OperationDefinition
                    {
                        Action = operationAction,
                        Channel = new V3ReferenceDefinition
                        {
                            Reference = $"#/channels/{Uri.EscapeDataString(fullTypeName)}"
                        },
                        Messages =
                        [
                            new V3ReferenceDefinition
                            {
                                Reference = $"#/channels/{Uri.EscapeDataString(fullTypeName)}/messages/{typeName}"
                            }
                        ]
                    };
                    document.Operations[$"{typeName}Operation"] = operation;
                }

                return document;
            }

    private void CollectTypeAndDependencies(Type type, Dictionary<string, (Type Type, string Namespace)> schemas)
    {
        var typeName = type.Name;
        var ns = type.Namespace ?? string.Empty;

        // Skip if already processed or if it's a primitive/system type
        if (schemas.ContainsKey(typeName) || IsSimpleType(type))
        {
            return;
        }

        schemas[typeName] = (type, ns);

        // Collect dependencies from properties
        foreach (var property in type.GetProperties(BindingFlags.Public | BindingFlags.Instance))
        {
            var propertyType = GetUnderlyingType(property.PropertyType);
            if (!IsSimpleType(propertyType) && propertyType.Namespace?.StartsWith("System") != true)
            {
                CollectTypeAndDependencies(propertyType, schemas);
            }
        }
    }

    private static Type GetUnderlyingType(Type type)
    {
        // Handle nullable types
        var nullableUnderlyingType = Nullable.GetUnderlyingType(type);
        if (nullableUnderlyingType is not null)
        {
            return nullableUnderlyingType;
        }

        // Handle collections (List<T>, IEnumerable<T>, etc.)
        if (type.IsGenericType)
        {
            var genericArgs = type.GetGenericArguments();
            if (genericArgs.Length == 1)
            {
                var genericDef = type.GetGenericTypeDefinition();
                if (genericDef == typeof(List<>) ||
                    genericDef == typeof(IList<>) ||
                    genericDef == typeof(ICollection<>) ||
                    genericDef == typeof(IEnumerable<>) ||
                    genericDef == typeof(HashSet<>))
                {
                    return genericArgs[0];
                }
            }
            // Handle Dictionary<K,V>
            if (genericArgs.Length == 2)
            {
                var genericDef = type.GetGenericTypeDefinition();
                if (genericDef == typeof(Dictionary<,>) ||
                    genericDef == typeof(IDictionary<,>))
                {
                    // For dictionaries, we care about the value type
                    return genericArgs[1];
                }
            }
        }

        // Handle arrays
        if (type.IsArray)
        {
            return type.GetElementType() ?? type;
        }

        return type;
    }

    private static bool IsSimpleType(Type type)
    {
        return type.IsPrimitive ||
               type.IsEnum ||
               type == typeof(string) ||
               type == typeof(decimal) ||
               type == typeof(DateTime) ||
               type == typeof(DateTimeOffset) ||
               type == typeof(TimeSpan) ||
               type == typeof(Guid) ||
               type == typeof(Uri) ||
               type == typeof(object);
    }

    private V3SchemaDefinition GenerateSchema(Type type, string ns)
    {
        // Use NJsonSchema to generate the JSON Schema
        var generator = new JsonSchemaGenerator(_schemaSettings);
        var jsonSchema = generator.Generate(type);

        // Convert NJsonSchema to a dynamic object for the Schema property
        var schemaJson = jsonSchema.ToJson();
        var schemaObject = JsonSerializer.Deserialize<ExpandoObject>(schemaJson);

        // Add our custom extension properties
        if (schemaObject is IDictionary<string, object?> dict)
        {
            dict[DotNetNamespaceExtension] = ns;
            dict[DotNetTypeExtension] = type.FullName ?? type.Name;

            // Convert $ref in definitions to components/schemas format
            ConvertReferences(dict);
        }

        return new V3SchemaDefinition
        {
            SchemaFormat = "application/schema+json;version=draft-07",
            Schema = schemaObject!
        };
    }

    private static void ConvertReferences(IDictionary<string, object?> dict)
    {
        foreach (var key in dict.Keys.ToList())
        {
            if (key == "$ref" && dict[key] is string refValue)
            {
                // Convert #/definitions/TypeName to #/components/schemas/TypeName
                dict[key] = refValue.Replace("#/definitions/", "#/components/schemas/");
            }
            else if (dict[key] is IDictionary<string, object?> nestedDict)
            {
                ConvertReferences(nestedDict);
            }
            else if (dict[key] is IList<object?> list)
            {
                foreach (var item in list)
                {
                    if (item is IDictionary<string, object?> itemDict)
                    {
                        ConvertReferences(itemDict);
                    }
                }
            }
        }
    }
}
